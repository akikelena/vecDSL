/*
 * generated by Xtext 2.27.0
 */
package org.xtext.example.domij.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.domij.services.DomijmasdslGrammarAccess;
import vecdslMM.Alter;
import vecdslMM.Cluster;
import vecdslMM.ClusterLimit;
import vecdslMM.CollectionLimit;
import vecdslMM.Connection;
import vecdslMM.Create;
import vecdslMM.Delete;
import vecdslMM.Drop;
import vecdslMM.EmbeddingModel;
import vecdslMM.FieldLimit;
import vecdslMM.Filter;
import vecdslMM.IndexLimit;
import vecdslMM.Insert;
import vecdslMM.NonVectorField;
import vecdslMM.NonVectorIndex;
import vecdslMM.NonVectorSearch;
import vecdslMM.Partition;
import vecdslMM.Script;
import vecdslMM.Update;
import vecdslMM.VecdslMMPackage;
import vecdslMM.VectorCollection;
import vecdslMM.VectorDatabase;
import vecdslMM.VectorField;
import vecdslMM.VectorIndex;
import vecdslMM.VectorSearch;

@SuppressWarnings("all")
public class DomijmasdslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DomijmasdslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == VecdslMMPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VecdslMMPackage.ALTER:
				sequence_Alter(context, (Alter) semanticObject); 
				return; 
			case VecdslMMPackage.CLUSTER:
				sequence_Cluster(context, (Cluster) semanticObject); 
				return; 
			case VecdslMMPackage.CLUSTER_LIMIT:
				sequence_ClusterLimit(context, (ClusterLimit) semanticObject); 
				return; 
			case VecdslMMPackage.COLLECTION_LIMIT:
				sequence_CollectionLimit(context, (CollectionLimit) semanticObject); 
				return; 
			case VecdslMMPackage.CONNECTION:
				sequence_Connection(context, (Connection) semanticObject); 
				return; 
			case VecdslMMPackage.CREATE:
				sequence_Create(context, (Create) semanticObject); 
				return; 
			case VecdslMMPackage.DELETE:
				sequence_Delete(context, (Delete) semanticObject); 
				return; 
			case VecdslMMPackage.DROP:
				sequence_Drop(context, (Drop) semanticObject); 
				return; 
			case VecdslMMPackage.EMBEDDING_MODEL:
				sequence_EmbeddingModel(context, (EmbeddingModel) semanticObject); 
				return; 
			case VecdslMMPackage.FIELD_LIMIT:
				sequence_FieldLimit(context, (FieldLimit) semanticObject); 
				return; 
			case VecdslMMPackage.FILTER:
				sequence_Filter(context, (Filter) semanticObject); 
				return; 
			case VecdslMMPackage.INDEX_LIMIT:
				sequence_IndexLimit(context, (IndexLimit) semanticObject); 
				return; 
			case VecdslMMPackage.INSERT:
				sequence_Insert(context, (Insert) semanticObject); 
				return; 
			case VecdslMMPackage.NON_VECTOR_FIELD:
				sequence_NonVectorField(context, (NonVectorField) semanticObject); 
				return; 
			case VecdslMMPackage.NON_VECTOR_INDEX:
				sequence_NonVectorIndex(context, (NonVectorIndex) semanticObject); 
				return; 
			case VecdslMMPackage.NON_VECTOR_SEARCH:
				sequence_NonVectorSearch(context, (NonVectorSearch) semanticObject); 
				return; 
			case VecdslMMPackage.PARTITION:
				sequence_Partition(context, (Partition) semanticObject); 
				return; 
			case VecdslMMPackage.SCRIPT:
				sequence_Script(context, (Script) semanticObject); 
				return; 
			case VecdslMMPackage.UPDATE:
				sequence_Update(context, (Update) semanticObject); 
				return; 
			case VecdslMMPackage.VECTOR_COLLECTION:
				sequence_VectorCollection(context, (VectorCollection) semanticObject); 
				return; 
			case VecdslMMPackage.VECTOR_DATABASE:
				sequence_VectorDatabase(context, (VectorDatabase) semanticObject); 
				return; 
			case VecdslMMPackage.VECTOR_FIELD:
				sequence_VectorField(context, (VectorField) semanticObject); 
				return; 
			case VecdslMMPackage.VECTOR_INDEX:
				sequence_VectorIndex(context, (VectorIndex) semanticObject); 
				return; 
			case VecdslMMPackage.VECTOR_SEARCH:
				sequence_VectorSearch(context, (VectorSearch) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Method returns Alter
	 *     Alter returns Alter
	 *
	 * Constraint:
	 *     (ddlConcept=Concept (ddlNode+=[DdlMethod|EString] ddlNode+=[DdlMethod|EString]*)? alterCond+=[Filter|EString] alterCond+=[Filter|EString]*)
	 * </pre>
	 */
	protected void sequence_Alter(ISerializationContext context, Alter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns ClusterLimit
	 *     ClusterLimit returns ClusterLimit
	 *
	 * Constraint:
	 *     (name=EString? type=EClusterLimit value=EString description=EString?)
	 * </pre>
	 */
	protected void sequence_ClusterLimit(ISerializationContext context, ClusterLimit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns Cluster
	 *     Cluster returns Cluster
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         vectordb=[VectorDatabase|EString] 
	 *         description=EString? 
	 *         nofCollections=EInt? 
	 *         (collections+=[VectorCollection|EString] collections+=[VectorCollection|EString]*)? 
	 *         (clusterLimits+=ClusterLimit clusterLimits+=ClusterLimit*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Cluster(ISerializationContext context, Cluster semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns CollectionLimit
	 *     CollectionLimit returns CollectionLimit
	 *
	 * Constraint:
	 *     (name=EString? type=EColectionLimit value=EString description=EString?)
	 * </pre>
	 */
	protected void sequence_CollectionLimit(ISerializationContext context, CollectionLimit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connection returns Connection
	 *
	 * Constraint:
	 *     (
	 *         host=EString 
	 *         port=EInt 
	 *         apiKey=EString? 
	 *         username=EString? 
	 *         password=EString? 
	 *         region=EString? 
	 *         userRole=EString? 
	 *         userPrivillege=EString? 
	 *         cloud=EString? 
	 *         environment=EString?
	 *     )
	 * </pre>
	 */
	protected void sequence_Connection(ISerializationContext context, Connection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Method returns Create
	 *     Create returns Create
	 *
	 * Constraint:
	 *     (ddlConcept=Concept (ddlNode+=[DdlMethod|EString] ddlNode+=[DdlMethod|EString]*)?)
	 * </pre>
	 */
	protected void sequence_Create(ISerializationContext context, Create semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Method returns Delete
	 *     Delete returns Delete
	 *
	 * Constraint:
	 *     (dmlCollection=VectorCollection (deleteCond+=[Filter|EString] deleteCond+=[Filter|EString]*)?)
	 * </pre>
	 */
	protected void sequence_Delete(ISerializationContext context, Delete semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Method returns Drop
	 *     Drop returns Drop
	 *
	 * Constraint:
	 *     (ddlConcept=Concept (ddlNode+=[DdlMethod|EString] ddlNode+=[DdlMethod|EString]*)? (dropCond+=[Filter|EString] dropCond+=[Filter|EString]*)?)
	 * </pre>
	 */
	protected void sequence_Drop(ISerializationContext context, Drop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns EmbeddingModel
	 *     EmbeddingModel returns EmbeddingModel
	 *
	 * Constraint:
	 *     (name=EString description=EString?)
	 * </pre>
	 */
	protected void sequence_EmbeddingModel(ISerializationContext context, EmbeddingModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns FieldLimit
	 *     FieldLimit returns FieldLimit
	 *
	 * Constraint:
	 *     (name=EString? type=EFieldLimit value=EString description=EString?)
	 * </pre>
	 */
	protected void sequence_FieldLimit(ISerializationContext context, FieldLimit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Filter returns Filter
	 *
	 * Constraint:
	 *     (filterField=[Concept|EString] operator=EOperator value=EString)
	 * </pre>
	 */
	protected void sequence_Filter(ISerializationContext context, Filter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VecdslMMPackage.Literals.FILTER__FILTER_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VecdslMMPackage.Literals.FILTER__FILTER_FIELD));
			if (transientValues.isValueTransient(semanticObject, VecdslMMPackage.Literals.FILTER__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VecdslMMPackage.Literals.FILTER__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, VecdslMMPackage.Literals.FILTER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VecdslMMPackage.Literals.FILTER__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFilterAccess().getFilterFieldConceptEStringParserRuleCall_0_0_1(), semanticObject.eGet(VecdslMMPackage.Literals.FILTER__FILTER_FIELD, false));
		feeder.accept(grammarAccess.getFilterAccess().getOperatorEOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getFilterAccess().getValueEStringParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns IndexLimit
	 *     IndexLimit returns IndexLimit
	 *
	 * Constraint:
	 *     (name=EString type=EIndexLimit value=EString description=EString?)
	 * </pre>
	 */
	protected void sequence_IndexLimit(ISerializationContext context, IndexLimit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Method returns Insert
	 *     Insert returns Insert
	 *
	 * Constraint:
	 *     (dmlCollection=VectorCollection path=EString nofRecords=EInt?)
	 * </pre>
	 */
	protected void sequence_Insert(ISerializationContext context, Insert semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns NonVectorField
	 *     Field returns NonVectorField
	 *     NonVectorField returns NonVectorField
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         colFieldOwner=[VectorCollection|EString] 
	 *         isPrimary?='primary'? 
	 *         type=EScalarDType 
	 *         (fieldLimits+=FieldLimit fieldLimits+=FieldLimit*)? 
	 *         (nonVectorIndexes+=NonVectorIndex nonVectorIndexes+=NonVectorIndex*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_NonVectorField(ISerializationContext context, NonVectorField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns NonVectorIndex
	 *     NonVectorIndex returns NonVectorIndex
	 *
	 * Constraint:
	 *     (name=EString? type=ENVIdxType description=EString?)
	 * </pre>
	 */
	protected void sequence_NonVectorIndex(ISerializationContext context, NonVectorIndex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Method returns NonVectorSearch
	 *     NonVectorSearch returns NonVectorSearch
	 *
	 * Constraint:
	 *     (
	 *         queryCollection=VectorCollection 
	 *         topK=EInt 
	 *         outputFields+=[Field|EString] 
	 *         outputFields+=[Field|EString]* 
	 *         (nonVecFilters+=Filter nonVecFilters+=Filter*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_NonVectorSearch(ISerializationContext context, NonVectorSearch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns Partition
	 *     Partition returns Partition
	 *
	 * Constraint:
	 *     (name=EString colPartOwner=[VectorCollection|EString] description=EString? partitionKey=[Field|EString])
	 * </pre>
	 */
	protected void sequence_Partition(ISerializationContext context, Partition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Script returns Script
	 *
	 * Constraint:
	 *     (vendor=EVendorName (methods+=Method methods+=Method*)?)
	 * </pre>
	 */
	protected void sequence_Script(ISerializationContext context, Script semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Method returns Update
	 *     Update returns Update
	 *
	 * Constraint:
	 *     (dmlCollection=VectorCollection path=EString nofRecords=EInt? updateCond+=[Filter|EString] updateCond+=[Filter|EString]*)
	 * </pre>
	 */
	protected void sequence_Update(ISerializationContext context, Update semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns VectorCollection
	 *     VectorCollection returns VectorCollection
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         cluster=[Cluster|EString] 
	 *         dynamic?='dynamic'? 
	 *         description=EString? 
	 *         (collectionLimits+=CollectionLimit collectionLimits+=CollectionLimit*)? 
	 *         fields+=[Field|EString] 
	 *         fields+=[Field|EString]* 
	 *         (partitions+=[Partition|EString] partitions+=[Partition|EString]*)? 
	 *         podtype=EPodTypes? 
	 *         podSize=EPodSize? 
	 *         podEnv=EPodEnv?
	 *     )
	 * </pre>
	 */
	protected void sequence_VectorCollection(ISerializationContext context, VectorCollection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns VectorDatabase
	 *     VectorDatabase returns VectorDatabase
	 *
	 * Constraint:
	 *     (name=EString connection=Connection description=EString? (clusters+=[Cluster|EString] clusters+=[Cluster|EString]*)?)
	 * </pre>
	 */
	protected void sequence_VectorDatabase(ISerializationContext context, VectorDatabase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns VectorField
	 *     Field returns VectorField
	 *     VectorField returns VectorField
	 *
	 * Constraint:
	 *     (
	 *         name=EString? 
	 *         colFieldOwner=[VectorCollection|EString] 
	 *         isPrimary?='primary'? 
	 *         type=EVectorDType 
	 *         embModel=[EmbeddingModel|EString]? 
	 *         (fieldLimits+=FieldLimit fieldLimits+=FieldLimit*)? 
	 *         (vectorIndexes+=VectorIndex vectorIndexes+=VectorIndex*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_VectorField(ISerializationContext context, VectorField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Concept returns VectorIndex
	 *     VectorIndex returns VectorIndex
	 *
	 * Constraint:
	 *     (name=EString? description=EString? metric=EMetricType type=EVIdxType (vIndexLimits+=IndexLimit vIndexLimits+=IndexLimit*)?)
	 * </pre>
	 */
	protected void sequence_VectorIndex(ISerializationContext context, VectorIndex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Method returns VectorSearch
	 *     VectorSearch returns VectorSearch
	 *
	 * Constraint:
	 *     (
	 *         queryCollection=VectorCollection 
	 *         topK=EInt 
	 *         metric=EMetricType 
	 *         numUnitsProbe=EInt? 
	 *         outputFields+=[Field|EString] 
	 *         outputFields+=[Field|EString]* 
	 *         (vecSearchFilters+=[Filter|EString] vecSearchFilters+=[Filter|EString]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_VectorSearch(ISerializationContext context, VectorSearch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
